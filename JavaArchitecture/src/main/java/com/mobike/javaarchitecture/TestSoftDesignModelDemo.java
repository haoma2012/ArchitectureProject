package com.mobike.javaarchitecture;import com.mobike.javaarchitecture.designpattern.behavior.User;import com.mobike.javaarchitecture.designpattern.behavior.chain.AbstractLogger;import com.mobike.javaarchitecture.designpattern.behavior.chain.ConsoleLogger;import com.mobike.javaarchitecture.designpattern.behavior.chain.ErrorLogger;import com.mobike.javaarchitecture.designpattern.behavior.chain.FileLogger;import com.mobike.javaarchitecture.designpattern.behavior.memento.CareTaker;import com.mobike.javaarchitecture.designpattern.behavior.memento.Originator;import com.mobike.javaarchitecture.designpattern.behavior.observer.BinaryObserver;import com.mobike.javaarchitecture.designpattern.behavior.observer.CObserver;import com.mobike.javaarchitecture.designpattern.behavior.observer.HexoObserver;import com.mobike.javaarchitecture.designpattern.behavior.observer.Subject;import com.mobike.javaarchitecture.designpattern.behavior.strategy.ContextStrategy;import com.mobike.javaarchitecture.designpattern.behavior.strategy.OperationAdd;import com.mobike.javaarchitecture.designpattern.behavior.strategy.OperationMultipy;import com.mobike.javaarchitecture.designpattern.behavior.strategy.OperationSubStract;import com.mobike.javaarchitecture.designpattern.behavior.template.Basketball;import com.mobike.javaarchitecture.designpattern.behavior.template.Football;import com.mobike.javaarchitecture.designpattern.behavior.template.Game;import com.mobike.javaarchitecture.designpattern.create.Singleton;import com.mobike.javaarchitecture.designpattern.create.abstractfactory.Color;import com.mobike.javaarchitecture.designpattern.create.abstractfactory.FactoryProducer;import com.mobike.javaarchitecture.designpattern.create.abstractfactory.Shape;import com.mobike.javaarchitecture.designpattern.create.abstractfactory.ShapeAbstractFactory;import com.mobike.javaarchitecture.designpattern.create.build.Meal;import com.mobike.javaarchitecture.designpattern.create.build.MealBuilder;import com.mobike.javaarchitecture.designpattern.create.clone.ShapeCache;import com.mobike.javaarchitecture.designpattern.create.clone.ShapeClone;import com.mobike.javaarchitecture.designpattern.create.factory.Product;import com.mobike.javaarchitecture.designpattern.create.factory.ProductFactory;import com.mobike.javaarchitecture.designpattern.structure.AudioPlayer;import com.mobike.javaarchitecture.designpattern.structure.facade.ShapeMakeFacade;import com.mobike.javaarchitecture.designpattern.structure.proxy.Image;import com.mobike.javaarchitecture.designpattern.structure.proxy.ProxyImage;/** * 软件设计模式Demo * 1.基本使用 * 2.深入设计分析原理 * 3.优缺点 * <p> * 创建型模式： * 工厂模式（Factory Pattern） * 抽象工厂模式（Abstract Factory Pattern） * 单例模式（Singleton Pattern） * 建造者模式（Builder Pattern） * 原型模式（Prototype Pattern） * 这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象 * <p> * 结构型模式： * 适配器模式（Adapter Pattern） * 桥接模式（Bridge Pattern） * 过滤器模式（Filter、Criteria Pattern） * 组合模式（Composite Pattern） * 装饰器模式（Decorator Pattern） * 外观模式（Facade Pattern） * 享元模式（Flyweight Pattern） * 代理模式（Proxy Pattern） * 这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。 * <p> * 行为型模式： * 责任链模式（Chain of Responsibility Pattern） * 命令模式（Command Pattern） * 解释器模式（Interpreter Pattern） * 迭代器模式（Iterator Pattern） * 中介者模式（Mediator Pattern） * 备忘录模式（Memento Pattern） * 观察者模式（Observer Pattern） * 状态模式（State Pattern） * 空对象模式（Null Object Pattern） * 策略模式（Strategy Pattern） * 模板模式（Template Pattern） * 访问者模式（Visitor Pattern） * 这些设计模式特别关注对象之间的通信。 * Created by yangdehao@xiaoyouzi.com  on 2019/2/14 上午10:12 */public class TestSoftDesignModelDemo {    public static void main(String[] args) {        /**         * 创建型设计模式         */        // 1.简单工厂模式：传递具体参数        ProductFactory simpleFactory = new ProductFactory();//        simpleFactory.createProdect();//        Product product = ProductFactory.createProduct("ProductA");        Product product = simpleFactory.getProduct("A");        product.name();        product.price();        // 2.抽象工厂方法模式        ShapeAbstractFactory shapeFactory = FactoryProducer.getFactory("SHAPE");        // 圆形        Shape ShapeCircle = shapeFactory.getShape("CIRCLE");        ShapeCircle.draw();        ShapeAbstractFactory colorFactory = FactoryProducer.getFactory("COLOR");        // 红色        Color redColor = colorFactory.getColor("RED");        redColor.fill();        // 3.单例模式        Singleton singleton = Singleton.getInstance();        singleton.showMessage();        // 4.建造者模式        MealBuilder builder = new MealBuilder();        Meal vegMeal = builder.prepareVegMeal();        vegMeal.showItems();        Meal nonVegMeal = builder.prepareNonVegMeal();        nonVegMeal.showItems();        // 5.原型模式        ShapeCache.loadCache(); // 加载cache 添加数据        ShapeClone cloneShape = ShapeCache.getShape("1");        System.out.println("Shape : " + cloneShape.getType());        /**         * 结构型设计模式         */        // 1.适配器模式 类适配器 对象适配器 接口适配器        AudioPlayer audioPlayer = new AudioPlayer();        audioPlayer.play("mp3", "beyond the horizon.mp3");        audioPlayer.play("mp4", "alone.mp4");        audioPlayer.play("vlc", "far far away.vlc");        audioPlayer.play("avi", "mind me.avi");        // 外观模式        ShapeMakeFacade shapeMakeFacade = new ShapeMakeFacade();        shapeMakeFacade.drawCircle();        shapeMakeFacade.drawSquare();        // 代理模式        Image image = new ProxyImage("test_10mb.jpg");        // 图像将从磁盘加载        image.display();        /**         * 行为型设计模式         */        // 中介者模式        User john = new User("john");        User juju = new User("juju");        john.sendMessage();        juju.sendMessage();        // 1.模板方法        Game game = new Football();        game.play();        game = new Basketball();        game.play();        // 备忘录模式        Originator originator = new Originator();        CareTaker careTaker = new CareTaker();        originator.setState("State #1");        originator.setState("State #2");        careTaker.add(originator.saveStateToMemento());        originator.setState("State #3");        careTaker.add(originator.saveStateToMemento());        originator.setState("State #4");        System.out.println("Current State: " + originator.getState());        originator.getStateFromMemento(careTaker.get(0));        System.out.println("First saved State: " + originator.getState());        originator.getStateFromMemento(careTaker.get(1));        System.out.println("Second saved State: " + originator.getState());        // 观察者模式        Subject subject = new Subject();        new BinaryObserver(subject);        new CObserver(subject);        new HexoObserver(subject);        System.out.println("First state change: 15");        subject.setState(15);        System.out.println("Second state change: 10");        subject.setState(10);        // 策略模式        ContextStrategy contextStrategy = new ContextStrategy(new OperationAdd());        System.out.println("10 + 5 = " + contextStrategy.executeStrategy(10, 5));        contextStrategy = new ContextStrategy(new OperationSubStract());        System.out.println("10 - 5 = " + contextStrategy.executeStrategy(10, 5));        contextStrategy = new ContextStrategy(new OperationMultipy());        System.out.println("10 * 5 = " + contextStrategy.executeStrategy(10, 5));        // 责令链模式        AbstractLogger loggerChain = getChainOfLoggers();        loggerChain.logMessage(AbstractLogger.INFO,                "This is an information.");        loggerChain.logMessage(AbstractLogger.DEBUG,                "This is a debug level information.");        loggerChain.logMessage(AbstractLogger.ERROR,                "This is an error information.");    }    private static AbstractLogger getChainOfLoggers() {        AbstractLogger consoleLogger = new ConsoleLogger(AbstractLogger.INFO);        AbstractLogger errorLogger = new ErrorLogger(AbstractLogger.ERROR);        AbstractLogger fileLogger = new FileLogger(AbstractLogger.DEBUG);        errorLogger.setNextLogger(fileLogger);        fileLogger.setNextLogger(consoleLogger);        return errorLogger;    }}